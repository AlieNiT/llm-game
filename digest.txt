Directory structure:
└── llm-game/
    ├── game.js
    ├── index.html
    ├── style.css
    └── server/
        └── server.js

================================================
File: game.js
================================================
const config = {
  type: Phaser.AUTO,
  width: 800,
  height: 600,
  scene: { preload, create, update },
  physics: { default: 'arcade' }
};

const game = new Phaser.Game(config);

let player, npcGroup, cursors, interactKey;
let chatPanel, chatInput, chatHistory, closeBtn, npcName;

let talking = false;
let currentNpc = null; // To track which NPC we are talking to

// Data for all NPCs in the game
const npcData = [
  { 
    name: 'Mushroom', 
    sprite: 'npc1',
    x: 300, y: 100, 
    message: 'I have a math question for you. What is $5 \\times (3+2)$?' 
  },
  { 
    name: 'Slime', 
    sprite: 'npc2',
    x: 500, y: 400, 
    message: 'I know a bit about our world. What is the name of the valley we live in?' 
  },
  { 
    name: 'Gem', 
    sprite: 'npc3',
    x: 150, y: 450, 
    message: 'I hold ancient knowledge. What element is the most abundant in the Earth\'s crust?'
  },
];

function preload() {
  this.load.image('player', 'https://labs.phaser.io/assets/sprites/phaser-dude.png');
  // Load a unique sprite for each NPC
  this.load.image('npc1', 'https://labs.phaser.io/assets/sprites/mushroom2.png');
  this.load.image('npc2', 'https://labs.phaser.io/assets/sprites/slime.png');
  this.load.image('npc3', 'https://labs.phaser.io/assets/sprites/blue_gem.png');
}

function create() {
  player = this.physics.add.sprite(100, 100, 'player');

  // Create a static group for all NPCs
  npcGroup = this.physics.add.staticGroup();

  // Create NPCs from the data array
  npcData.forEach(data => {
    const npc = npcGroup.create(data.x, data.y, data.sprite);
    // Attach custom data to the NPC game object
    npc.name = data.name;
    npc.message = data.message;
  });

  this.physics.add.collider(player, npcGroup);

  cursors = this.input.keyboard.createCursorKeys();
  interactKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E);

  // Chat elements
  chatPanel = document.getElementById('chatPanel');
  chatInput = document.getElementById('chatInput');
  chatHistory = document.getElementById('chatHistory');
  closeBtn = document.getElementById('closeBtn');
  npcName = document.getElementById('npcName');

  chatInput.addEventListener('keydown', onChatSubmit);
  closeBtn.addEventListener('click', closeChat);
}

function update() {
  // Player movement logic should not run when chatting
  if (!talking) {
    player.setVelocity(0);
    if (cursors.left.isDown) player.setVelocityX(-160);
    else if (cursors.right.isDown) player.setVelocityX(160);
    if (cursors.up.isDown) player.setVelocityY(-160);
    else if (cursors.down.isDown) player.setVelocityY(160);
  }

  // Check for interaction key press
  if (Phaser.Input.Keyboard.JustDown(interactKey)) {
    if (!talking) {
      // Find the closest NPC in range to interact with
      for (const npc of npcGroup.getChildren()) {
        if (Phaser.Math.Distance.Between(player.x, player.y, npc.x, npc.y) < 60) {
          openChat(npc);
          break; // Interact with the first NPC in range and stop checking
        }
      }
    }
  }
}

function openChat(npc) {
  talking = true;
  currentNpc = npc; // Store reference to the current NPC
  
  player.setVelocity(0); // Stop player movement
  
  npcName.textContent = npc.name; // Update chat header with NPC's name
  chatPanel.style.display = 'flex';
  chatHistory.innerHTML = `<div><b>${npc.name}:</b> ${npc.message}</div>`;
  chatInput.value = '';
  chatInput.focus();
}

function closeChat() {
  chatPanel.style.display = 'none';
  talking = false;
  currentNpc = null; // Clear the current NPC
}

async function onChatSubmit(e) {
  if (e.key === 'Enter') {
    const input = chatInput.value.trim();
    if (input === '' || !currentNpc) return;

    // Display player's message immediately
    chatHistory.innerHTML += `<div><b>You:</b> ${input}</div>`;
    chatInput.value = ''; // Clear input field
    chatHistory.scrollTop = chatHistory.scrollHeight;

    // Show a "typing" indicator for the NPC
    const thinkingMessage = document.createElement('div');
    thinkingMessage.innerHTML = `<b>${currentNpc.name}:</b> ...`;
    chatHistory.appendChild(thinkingMessage);
    chatHistory.scrollTop = chatHistory.scrollHeight;


    try {
      // **Call your proxy server**
      const response = await fetch('http://localhost:3000/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ message: input }),
      });

      if (!response.ok) {
        throw new Error('Network response was not ok');
      }

      const data = await response.json();
      
      // Extract the text from the Gemini response
      const reply = data.candidates[0].content.parts[0].text;

      // Update the "typing" message with the actual reply
      thinkingMessage.innerHTML = `<div><b>${currentNpc.name}:</b> ${reply}</div>`;

    } catch (error) {
      console.error('Error fetching from proxy server:', error);
      thinkingMessage.innerHTML = `<div><b>${currentNpc.name}:</b> Sorry, I'm having trouble thinking right now.</div>`;
    } finally {
        chatInput.focus();
        chatHistory.scrollTop = chatHistory.scrollHeight; // Scroll to the latest message
    }
  }
}



================================================
File: index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>LLM Game MVP</title>
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
</head>
<body>
  <script src="game.js"></script>
  <div id="chatPanel">
  <div id="chatHeader">
    <span id="npcName">NPC Chat</span>
    <button id="closeBtn">X</button>
  </div>
  <div id="chatHistory"></div>
  <input type="text" id="chatInput" placeholder="Type your message..." />
</div>
</body>
</html>



================================================
File: style.css
================================================
body {
  margin: 0;
  overflow: hidden;
}
#chatPanel {
  position: absolute;
  width: 400px;
  height: 300px;
  bottom: 10px;
  left: 10px;
  background: #222;
  color: #fff;
  border: 2px solid #555;
  display: none;
  flex-direction: column;
  font-family: sans-serif;
}

#chatHeader {
  background: #444;
  padding: 5px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

#chatHistory {
  flex: 1;
  padding: 10px;
  overflow-y: auto;
  font-size: 14px;
}

#chatInput {
  border: none;
  padding: 10px;
  font-size: 14px;
  width: 100%;
  box-sizing: border-box;
}

#closeBtn {
  background: #900;
  color: white;
  border: none;
  cursor: pointer;
  padding: 4px 8px;
}



================================================
File: server/server.js
================================================
require('dotenv').config();
const express = require('express');
const fetch = require('node-fetch');
const cors = require('cors');
const { HttpsProxyAgent } = require('https-proxy-agent'); // Note the curly braces

const app = express();
const port = 3000;

app.use(express.json());
app.use(cors());

const API_KEY = process.env.GEMINI_API_KEY;

app.post('/chat', async (req, res) => {
  if (!API_KEY) {
    return res.status(500).json({ error: 'API key not configured' });
  }

  const { message } = req.body;
  if (!message) {
    return res.status(400).json({ error: 'Message is required' });
  }

  // Define the proxy agent
  const proxyUrl = 'http://127.0.0.1:2081';
  const agent = new HttpsProxyAgent(proxyUrl);

  const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent';
  
  const payload = {
    contents: [{
      parts: [{
        text: message
      }]
    }]
  };

  try {
    // Pass the agent to the fetch options
    const apiResponse = await fetch(`${url}?key=${API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload),
      agent: agent // This line routes the request through your proxy
    });

    if (!apiResponse.ok) {
        const errorData = await apiResponse.text();
        throw new Error(`API call failed with status: ${apiResponse.status}, details: ${errorData}`);
    }

    const data = await apiResponse.json();
    res.json(data);
  } catch (error) {
    console.error('Error calling Google AI API:', error);
    res.status(500).json({ error: 'Failed to get response from AI' });
  }
});

app.listen(port, () => {
  console.log(`Proxy server listening at http://localhost:${port}`);
});


